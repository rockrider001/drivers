/*!
 * @defgroup etimer_drv ETIMER Driver
 * @ingroup etimer
 * @brief Enhanced Motor Control Timer Peripheral Driver.
 *
 * ## Hardware background ##
 * An eTimer module provides:
 *    - Six identical counter/timer channels
 *    - On MPC574xP and S32S247TV devices, one watchdog timer function for peripheral 0 only
 * Each 16-bit counter/timer channel contains a prescaler, a counter, a load register, a hold
 * register, two queued capture registers, two compare registers, two compare preload
 * registers, and four control registers.
 * Note
 * This document uses the terms "Timer" and "Counter"
 * interchangeably because the counter/timers may perform either
 * or both tasks.
 * The Load register provides the initialization value to the counter when the counter's
 * terminal value has been reached. For true modulo counting the counter can also be
 * initialized by the CMPLD1 or CMPLD2 registers.
 * 
 * The Hold register captures the counter's value when other counters are being read. This
 * feature supports the reading of cascaded counters coherently.
 * The Capture registers enable an external signal to take a "snap shot" of the counter's
 * current value.
 * The COMP1 and COMP2 registers provide the values to which the counter is compared.
 * If a match occurs, the OFLAG signal can be set, cleared, or toggled. At match time, an
 * interrupt is generated if enabled, and the new compare value is loaded into the COMP1 or
 * COMP2 registers from CMPLD1 and CMPLD2 if enabled.
 * The Prescaler provides different time bases useful for clocking the counter/timer.
 * The Counter provides the ability to count internal or external events.
 * Within the eTimer module, the input pins are shareable.
 *  
 * Each ETIMER timer channel require at least three members in the configuration structure to be set to a proper value.
 * These mebmbers are <i>"timerMode"</i> and <i>"coreSettings"</i> and <i>"primaryInput"</i>.
 * All other members will be ignored or used depending on the combination of the set values in <i>"timerMode"</i> and <i>"coreSettings"</i>.
 * 
 * <b><i>"timerMode"</i></b> will configure in which mode the driver will run:@n
 * - <b>Stop mode</b>: In this mode the counter will be stopped, even if we configure other values.@n
 * - <b>Periodic Counter</b>: In this mode, the driver will configure the counter to run as a standard 16-bit periodic counter.@n
 * - <b>One Shot Counter</b>: In this mode, the counter will stop when it reaches the maximum value of 0xffff, if counting up,
 * or 0 if counting down.@n
 * - <b>Pulse Output</b>: In this mode, a series of pulses will be generated on the channel output pin.@n
 * - <b>PWM Output</b>: In this mode, a fixed frequency PWM will be available on the channel output pin.@n
 * - <b>VPWM Output</b>: In this mode, a variable frequency PWM signal will be available on the channel output pin.@n
 * - <b>Modulo Counter</b>: In this mode, you can change the maximum counting value to any number between 0 and 0xffff.@n
 * - <b>Input Capture</b>: In this mode, the counter value will be stored in the corresponding capture registers when
 * an configurable input condition is met.@n
 * - <b>Input Capture One Shot</b>: Same as bove mode but will stop after both compare registers have a value stored in them.@n
 * - <b>Output Compare</b>: In this mode, a signal will be available on the output pin, according to the settings given by the user.@n
 * - <b>Output Compare One Shot</b>: Same as above mode but will stop when the counter reaches the maximum value of 0xffff, if counting up,
 * or 0 if counting down.@n
 * - <b>Fast Cascade</b>: In this mode, two channels can be cascaded using a fast hardware connection which bypasses the usual input muxer.
 * This mode is limited to two counters per ETIMER peripheral !@n
 * 
 * <b><i>"coreSettings"</i></b> will configure in which mode the internal hardware counter will run:@n
 * - <b>Normal</b>: In this mode the counter will use the primary input as clock source and will ignore the secondary input.@n
 * - <b>Both Edge</b>: Similar to "Normal" mode, but it will use both clock edged for counting.@n
 * - <b>Gated</b>: In this mode, the counter will use the primary input as clock source and use the secondary input as start/stop signal,
 * it will count as long as the secondary input is active.@n
 * - <b>Quadrature</b>: In this mode the counter will use both the primary input and the secondary input as clock source.
 * The clock must be quadrature encoded, counter direction will be established by the clock.@n
 * - <b>Signed</b>: In this mode the counter will use the primary input as clock source and the secondary input as counter direction.@n
 * - <b>Triggered</b>: In this mode the counter will use the primary input as clock source and will wait for the secondary input to change
 * state according to the configuration.
 *
 * ## Driver consideration ##
 * The Driver uses structures for configuration. Each structure contains members that are specific to its respective functionality.
 * 
 * These structures are:
 * - \b etimer_user_channel_config_t : configuration for one channel of the ETIMER instance.@n
 * - \b etimer_dma_channel_t : configures the behavior of a DMA channel available in the ETIMER instance.
 *
 * ## Interrupt handling ##
 * Each ETIMER timer channel has a corresponding interrupt handler. The ETIMER Driver does not define interrupt handler internally.
 * These interrupt handler methods can be defined by the user application.
 * There are two ways to add an ETIMER interrupt handler:
 *  1. Using the weak symbols defined by start-up code. if the methods
 *      <tt>ETIMER<b>x</b>_Handler(void)</tt> (x denotes instance number) are not
 *      defined, the linker use a default ISR. An error will be generated if
 *      methods with the same name are defined multiple times. This method works
 *      regardless of the placement of the interrupt vector table (Flash or RAM).
 *  2. Using the Interrupt Manager's <tt>INT_SYS_InstallHandler()</tt> method. This can
 *      be used to dynamically change the ISR at run-time. This method works
 *      only if the interrupt vector table is located in RAM.
 *
 * ## Clocking configuration ##
 * The ETIMER Driver does not handle clock setup (from PCC) configuration. This is handled by the Clock Manager. The driver assumes that clock
 * configurations have been made, so it is the user's responsibility to set up
 * clocking and pin configurations correctly.
 *
 * ## Basic operations ##
 * 1. Pre-Initialization information of ETIMER module
 *   - Before using the ETIMER driver, the protocol clock of the module must be configured by the application using PCC
 *     module.
 *   - Configures Trigger MUX Control (TRGMUX) if want to use external trigger for ETIMER module.
 *   - Configures different peripherals if want to use them in ETIMER interrupt routine.
 *   - Provides configuration data structure to ETIMER initialization API.

 * 2. To initialize the ETIMER module, just call the ETIMER_DRV_Init() function.
 *     This function configures and enables the ETIMER module operation. This function must be called first.@n
 *     In the following code, ETIMER module is initialized.
  ~~泾￣溴骈铄B狭夷吲陨团疫晌釉廖门0?
*  /　深轸獒扉?　翳　旁赏乓m镤蹯瀹*?
*  E陨团疫囊诌深轸孪烈倪旁赏乓呱斡粤蚊农箕靠楚　伶翦　汜祆轭　翳　旁赏乓吣抑呱铋舁　骢钽糸镱　汜祆E陨团疫囊诌深轸描犷铄歙　骢钽糸镱w轸　躞弪c栳铑屐c镱骈珲蜥糸镱
*  s趄蹉趱蝈t　轭轸獒扉?t轫弪c栳铑屐俐轧栝　骢钽糸镱c镱骈珲蝈　糸礤　汨犷铄　汨衢铋铉　糸礤　汨犷铄　盹溴　糸礤　汨犷铄　泔躅翦　盹溴　轭翦蝌躔　珏铄蜥糸镱?
*  p蜷磲蝙i铕豸s秕蜚瀣s邈镱溽蝙i铕豸s秕蜚瀣o豸瘐　泔眇狎　犷　轭瘐　汜痿躜　镳糸镱螽
*  I　翳　骘祆秣轭　泔溴　糸礤　汨犷铄　轶i铋糸犰辁邃w轸　轭翦蝌躔　珏铄蜥糸镱o　糸礤　秭弪骒秣i　孱徕戾洮
*  o疱蜥糸镱m镤　轶f轼邃f蝈聃孱泫g孱弪狒轱　凶同h狎澉狎　泔躅翦　轶s弭t　铒蝽犰m镤　躔滹黝c秕铘轭绗
*  u箦p蜷磲蝙i铕豸a　沆镢　箫躜沐┈p蜷磲蝙i铕豸s弭t　疱蜷痂弪犰c祜汶d轹殇邃b　船o豸瘐　痖　孱徕戾洮P淄f徙麸?
*  i　箦　鏖翳c镯疳蝈轴祯弩m屙忮　麸a怙豸3　疱蜚孱舢N雉　翳狒i　凶　盹溴w　镱禊r羼蹰蝈t桢箦s弭糸铉蟋a祆o翳弪?
*  a蝈n雉u箦　犷　狎　桢蝈j躞　麸s弭ak铒黝v犰蹂?
 ??泾　描犷铄　　泔铈殓躜狒轱　篝蝓泗躜　
*  e糸礤蜻躞弪咩栳铑屐咩镱骈邕　汨铎泔铈殓=
*  {
*    .糸礤蛲镤褰旁赏乓咄夏胚粕嘏倪凶同
*    .泔蝈渝趑轭珞脚陨团疫孟瘴耘疫蜗彝撂?
*    .痱轫狎?铕豸?
*    {
*      E陨团疫晌哂颐呙趟吣芍叽?
*      E陨团疫邢塘疑再咝嫌稍芍努
*    }?
*    .箦泔钿狎?铕豸?
*    {
*      E陨团疫晌哂颐呙卧边晌?
*      E陨团疫邢塘疑再呶徘猎芍努
*    }?
*    .轭瘐羝殪翦蚪
*    {
*      E陨团疫粕淘呙卧叱?
*      0?
*    }?
*    .秕麴豸虚罱
*    {
*      t蝓瀣
*      E陨团疫邢塘疑再咝嫌稍芍努
*    }?
*    .泔眇狎逄镝溟铉?
*    {
*      E陨团疫锰眠埔贤呙托棠边兹盼呙贤斜?
*      E陨团疫锰眠埔贤呙托棠策兹盼呙贤胁?
*    }?
*    .泔眇狎逯犰蹂蠼
*    {
*      0?鞍艾
		    傍骀骀?
*    }?
*    .泔躅裟轵邈糸镱脚陨团疫孟瘴赃招?
*    .泔眇狎逑豸瘐裘镱趄镬脚陨团疫险酝夏胚酉圃琢遗?
*    .泔眇狎逋镤褰旁赏乓呙托拖呐呙贤斜哒羞孟托策招?
*    .汜痿躜迕镱趄镬
*    {
*      E陨团疫眯酝夏胚纳恿绿拍?
*      E陨团疫眯酝夏胚纳恿绿拍?
*    }
*    .汜痿躜遄矧潴桨?
*    .轭翦蝌躔襞钺忪逋狍虢旁赏乓呙冗梢堰酉找门咴掀膳?
*  }?
*  /　深轸獒扉?　翳　汨犷铄　　
*  E陨团疫囊诌深轸描犷铄歙孪烈倪旁赏乓呱斡粤蚊努0　汨铎泔铈殓?
 ???
*
*4　燥s翎螋t轫弪c栳铑屐c秕铘轭绗j躞　汜祆E陨团疫囊诌郁狎粼轫弪描犷铄祗īw轸　糸礤　汨犷铄祗s翎螋轭　磲箅?
*  I　翳　骘祆秣轭　泔溴　翳　糸礤　汨犷铄　　轶s翎螋邃w轸　翳　磲箅o　旁赏乓吲瘟绿胚萌爱
 ??泾　郁狎趔c栳铑屐0c秕铘轭绐?
*  E陨团疫囊诌郁狎粼轫弪描犷铄祗孪烈倪旁赏乓呱斡粤蚊拧∨陨团疫盼谅膛呙劝?
 ???
*
*5　燥s麸　糸礤　汨犷铄　泔躅糸铉　牾篝c犰　旁赏乓吣抑哂麸鹪轫弪描犷铄祗īw轸　糸礤　汨犷铄祗s麸痧轭　磲箅?
*  I　翳　骘祆秣轭　泔溴　翳　糸礤　汨犷铄　　轶s麸痧邃w轸　翳　磲箅o　旁赏乓吲瘟绿胚萌爱
 ??泾　郁镳　汨犷铄　　泔躅糸铉
*  E陨团疫囊诌郁镳蚤礤蛎栳铑屐蟥孪烈倪旁赏乓呱斡粤蚊努E陨团疫盼谅膛呙劝┗
 ???
*
*6　燥d轶徕戾E陨团　盹漉戾　牾篝c犰　旁赏乓吣抑吣彘铋舁┊
 ??泾　拈筢忪弩E陨团　盹漉戾
*  E陨团疫囊诌腻轭轸孪烈倪旁赏乓呱斡粤蚊农箕靠￣　深翦珧狒轱　珲殇屐轭　＃
*
*#＃C镯痖灬糸镱u铋趔#＃
*
*T桢f镬祜鏖铉f殪弩n邋　麸b　泔眇殪邃i　翳　痱镪邈艉
*\鲥蜮狒轫
$?巢幽诉辛匀?痨狒骘蝽茕蜷鲥蝮荏蜚苠糸礤蜍弭轫弪咪蜷鲥虍?
$?巢幽诉辛匀?痨狒骘蝽茕蜷鲥蝮荏蜚苠糸礤蜍弭轫弪哞鬟徙沐篌泾荥孱漩弪忉糸?
*
*#＃I钽祯溴p狒　＃?
*
*T桢f镬祜鏖铉p狒梵n邋　麸b　徜溴　麸t桢i钽祯溴p狒　镦t桢t镲煦栳轭?
*\鲥蜮狒轫
$?巢幽诉辛匀?痨狒骘蝽茕蜷鲥蝮荛钽?
\孱漩弪忉糸?
*
*#＃P蝈痱镢弩箫　簌礅镬　＃?
*
*N　箴邈獒　簌礅镬　狎　蝈聃轵邃f矧t栝　泔眇镱孱?
*
*#＃D屦孱溴钽殄　＃?
\蝈　沆镢脒磲钺珏　茴
\蝈　轭翦蝌躔暨磲钺珏　茴
*
*#　祟秣　扉黹翎糸镱蠛#?
*T桢f镬祜鏖铉i　　铒瞽屮栳躞糸鲥l轶　镦k铒　扉黹翎糸镱　轭t桢c躜蝈铘i眇戾礤铘狒轱詈李
*-"泔躅裟轵邈糸镱　鲠祯　轶i珙矧邃w桢　泔蝈渝趑轭珞i　箦　麸"旁赏乓呙险卧乓哂汕闻蘑　李
*-u箝铉a铢o　翳　镱瀛箬雉m镤弩w殪　篝镳t桢h狎澉狎　汨犷铄　徭翦　翳　弼孱　镢沲蝮　麸r弩弭i铋糸犰辁　犷　翳孱s翎螋t桢c栳铑屐　
*?
*