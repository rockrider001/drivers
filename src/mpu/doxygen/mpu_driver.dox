/*!
   @defgroup mpu Memory Protection Unit (MPU)
   @brief The S32 SDK provides Peripheral Driver for the Memory Protection Unit (MPU) module of S32 SDK devices.
   @details The memory protection unit (MPU) provides hardware access control for all memory references generated in the device.@n

   ## Hardware background ##

    The MPU concurrently monitors all system bus transactions and evaluates their
    appropriateness using pre-programmed region descriptors that define memory spaces and
    their access rights. Memory references that have sufficient access control rights are
    allowed to complete, while references that are not mapped to any region descriptor or
    have insufficient rights are terminated with a protection error response.

    The MPU implements a two-dimensional hardware array of memory region descriptors
    and the crossbar slave ports to continuously monitor the legality of every memory
    reference generated by each bus master in the system.

    The feature set includes:
    - 8(16 for S32K148 and MPC577xx) program-visible 128-bit region descriptors, accessible by four 32-bit words each
      - Each region descriptor defines a modulo-32 byte space, aligned anywhere in
        memory
        - Region sizes can vary from 32 bytes to 4 Gbytes
      - Two access control permissions defined in a single descriptor word
        - Masters 0–3: read, write, and execute attributes for supervisor and user
          accesses
        - Masters 4–7: read and write attributes
      - Hardware-assisted maintenance of the descriptor valid bit minimizes coherency
        issues
      - Alternate programming model view of the access control permissions word
      - Priority given to granting permission over denying access for overlapping region
        descriptors
    - Detects access protection errors if a memory reference does not hit in any memory
      region, or if the reference is illegal in all hit memory regions. If an access error
      occurs, the reference is terminated with an error response, and the MPU inhibits the
      bus cycle being sent to the targeted slave device.
    - Error registers, per slave port, capture the last faulting address, attributes, and other
      information
    - Global MPU enable/disable control bit

   <b>Logical Bus Master Assignments and Possible Access Types</b> \n
   <i>On S32K1xx and S32MTV</i>
      ID  |    Master    |User|Supervisor|Data|Instruction|Read|Write|Execute| PID  |
    :----:|:------------:|:--:|:--------:|:--:|:---------:|:--:|:---:|:-----:|:----:|
      0   |    Core      | x  |    x     | x  |     x     | x  |  x  |   x   |  x   |
      1   |    Debugger  | x  |    x     | x  |     x     | x  |  x  |   x   |  x   |
      2   |    DMA       |    |    x     | x  |           | x  |  x  |       |      |
      3   |    ENET(1)   | x  |          | x  |           | x  |  x  |       |      |
    1: S32K148 only.

   <i>On MPC577xx</i>
      ID  |    Master    |User|Supervisor|Data|Instruction|Read|Write|Execute| PID  |
    :----:|:------------:|:--:|:--------:|:--:|:---------:|:--:|:---:|:-----:|:----:|
      0   |    CORE 0    | x  |    x     | x  |     x     | x  |  x  |   x   |  x   |
      1   |    CORE 1    | x  |    x     | x  |     x     | x  |  x  |   x   |  x   |
      2   |    FEC       | x  |    x     | x  |     x     | x  |  x  |   x   |  x   |
      3   |    CSE       | x  |    x     | x  |     x     | x  |  x  |   x   |  x   |
      4   |    eDMA_A    |    |          | x  |           | x  |  x  |       |      |
      5   |    eDMA_B    |    |          | x  |           | x  |  x  |       |      |
      6   |    SIPI(1)   |    |          | x  |           | x  |  x  |       |      |
    1: MPC5777C only.

   <b>Logical Slave Port Assignments</b>
     Port |       S32K11x      |     S32K14x      |      S32MTV      | MPC577xx |
    :----:|:------------------:|:----------------:|:----------------:|:--------:|
      0   | Flash Controller   | Flash Controller | Flash Controller |  EBI     |
      1   | SRAM controller(1) | SRAM backdoor    | SRAM backdoor    |  PRAMC   |
      2   |                    | SRAM_L frontdoor | SRAM_L frontdoor |  AIPS    |
      3   |                    | SRAM_U frontdoor | SRAM_U frontdoor |          |
      4   |                    | QuadSPI(2)       |                  |          |
    1: Destination: SRAM controller/MTB/DWT/MCM. \n
    2: S32K148 only.

    <b>Note</b>: Region 0 shouldn't be config on S32K1xx and S32MTV.

   ## AHB-AP ##

    AHB-AP provides the debugger access to all memory and registers in the system.\n
    The MPU includes default settings and protections for the Region Descriptor 0 (RGD0)
    such that the Debugger always has access to the entire address space and those rights
    cannot be changed by the core or any other bus master.

   ## ERRATA ##
    - S32K148:
      - E11109: The MPU requires a special programming sequence to protect the QSPI space
        as it is unable to see the two MSB bits of the QSPI address on slave port 4.\n
        This programming sequence requires 2 Region Descriptors [RGDx]:
        - One will cover the region 0x280x_xxxx and the other one will cover region 0x680x_xxxx.
        - When any master without permissions tries to access region 0x680x_xxxx, an error will be captured in both, EDR3 and EDR4 registers.
          Moreover, the address of the failed access is captured on EAR3 and EAR4 registers. However, EAR3 will capture the address 0x680x_xxxx,
          which is the one that belongs to the QSPI space. While EAR4 will capture the 0x280x_xxxx address.

   ## Notes ##
    - MPC577xx:
      The e200z7 core have instruction pipeline, it will generate a pair of intructions each cycle to the execution unit. MPU component gets the most recent access error.

 */

/*!
## Integration guideline ##

### Compilation units ###

The following files need to be compiled in the project:
\verbatim
${S32SDK_PATH}\platform\drivers\src\mpu\mpu_driver.c
${S32SDK_PATH}\platform\drivers\src\mpu\mpu_hw_access.c
\endverbatim

### Include path ###

The following paths need to be added to the include path of the toolchain:
\verbatim
${S32SDK_PATH}\platform\drivers\inc\
\endverbatim

### Preprocessor symbols ###

No special symbols are required for this component

### Dependencies ###

No special dependencies are required for this component

 */

/*!
@defgroup mpu_drv MPU Driver
@ingroup mpu

# Pre-Initialization information of MPU module

1. Before using the MPU driver the protocol clock of the module must be configured by the application using clock module.
2. Bus fault or Hard fault exception must be configured to handle MPU access violation.


## Initialization and Deinitialize{#MPUInit}

To initialize the MPU module, call the MPU_DRV_Init() function and provide the user configuration data structure.
This function sets the configuration of the MPU module automatically and enables the MPU module. \n
The default settings for the Region Descriptor 0 (RGD0):
 - The access right for <b>CORE, DMA,..</b> can be <b>changed</b> except <b>DEBUGGER</b> master.
 - The <b>start address</b>, <b>end address</b>, <b>process identifier</b> and <b>process identifier mask</b> are <b>ignored</b>.

This is example code to configure the MPU driver on S32K1xx:
1. Define MPU instance
~~~~~{.c}
    /* MPU 0 */
    #define INST_MPU 0U

    /* Status variable */
    status_t status;
~~~~~

2. Configuration \n
User configuration
~~~~~{.c}
    /* Region count */
    #define REGION_CNT (1U)

    /* Master access configuration
     * FEATURE_MPU_MASTER_COUNT macro has been already defined (number of masters supported by hardware)
     */
    mpu_master_access_right_t masterAccRight[FEATURE_MPU_MASTER_COUNT] =
    {
       /* CORE */
        {
            .masterNum   = FEATURE_MPU_MASTER_CORE,        /* Master number */
            .accessRight = MPU_SUPERVISOR_RWX_USER_RWX,    /* Access right */
            .processIdentifierEnable = false,              /* Process identifier enable */
        },
        /* The rest masters should be defined here */
        ...
    }
    /* User configuration */
    mpu_user_config_t userConfig[REGION_CNT] =
    {
        /* Region 0 */
        {
            .startAddr          = 0x00000000U,       /* Memory region start address */
            .endAddr            = 0xFFFFFFFFU,       /* Memory region end address */
            .masterAccRight     = masterAccRight,    /* Master access right */
            .processIdEnable    = false,             /* Process identifier enable */
            .processIdentifier  = 0x00U,             /* Process identifier */
            .processIdMask      = 0x00U              /* Process identifier mask */
        }
    }
~~~~~
or get default configuration
~~~~~{.c}
    /* Defines master access right structure */
    mpu_master_access_right_t masterAccRight[FEATURE_MPU_MASTER_COUNT];

    /* Gets default region configuration
     * Cover entire memory
     * Access right of all masters are allowed
     */
    mpu_user_config_t regionConfig0 = MPU_DRV_GetDefaultRegionConfig(masterAccRight);
    mpu_user_config_t userConfig[REGION_CNT] =
    {
        regionConfig0
    };
~~~~~

3. Initializes
~~~~~{.c}
    /* Initializes the MPU instance */
    status = MPU_DRV_Init(INST_MPU, REGION_CNT, userConfig);
~~~~~

4. De-initializes
~~~~~{.c}
    /* De-initializes the MPU instance */
    MPU_DRV_Deinit(INST_MPU);
~~~~~

## Basic Control Operations {#MPUBasicOp}

After MPU initialization:
- The MPU_DRV_SetRegionConfig() can be used to add/update the new/existing region descriptor.
~~~~~{.c}
    /* Add the new region descriptor.
       Region 1 to be the same with region 0.
     */
    status = MPU_DRV_SetRegionConfig(INST_MPU, 1U, &userConfig[0U]);

    /* Updates the existing region descriptor.
       Updates PID mask value on region 1.
     */
    userConfig[0U].processIdMask = 0xFFU;
    status = MPU_DRV_SetRegionConfig(INST_MPU, 1U, &userConfig[0U]);
~~~~~
- The MPU_DRV_SetRegionAddr() can be used to update the start and end address on an existing region descriptor.
~~~~~{.c}
    /* Updates region 1 location (0x20000000 - 0x2FFFFFFF) */
    MPU_DRV_SetRegionAddr(INST_MPU, 1U, 0x20000000U, 0x2FFFFFFFU);
~~~~~
- The MPU_DRV_SetMasterAccessRights() can be used to update access permission of master in the region.
~~~~~{.c}
    /* DMA can only operate on region 1 */
    mpu_master_access_right_t DMA_AccRight;
    DMA_AccRight.masterNum = FEATURE_MPU_MASTER_DMA;
    /* Removes all access rights of DMA on region 0 */
    DMA_AccRight.accessRight = MPU_SUPERVISOR_USER_NONE;
    status = MPU_DRV_SetMasterAccessRights(INST_MPU, 0U, &DMA_AccRight);
    /* Allows all access to region 1 from DMA */
    DMA_AccRight.accessRight = MPU_SUPERVISOR_USER_RWX;
    status = MPU_DRV_SetMasterAccessRights(INST_MPU, 1U, &DMA_AccRight);
~~~~~
- The MPU_DRV_GetDetailErrorAccessInfo() API can be used to get the status of a slave port and the detail when an error occurred.
~~~~~{.c}
    /* DMA access to SRAML
       - Access type: read
       - Address: 0x1FFEFF00 (region 0)
     */
    ...
    /* Checks and gets error status on slave port 1 (SRAML backdoor) */
    bool errStatus = false;
    mpu_access_err_info_t errReport;
    errStatus =  MPU_DRV_GetDetailErrorAccessInfo(INST_MPU, FEATURE_MPU_SLAVE_SRAM_BACKDOOR, &errReport);
    /* Checks status:
      - errStatus: true
      - errReport:
        - errReport.master: FEATURE_MPU_MASTER_DMA (DMA logical ID)
        - errReport.attributes: MPU_DATA_ACCESS_IN_SUPERVISOR_MODE (Data access in supervisor mode)
        - errReport.accessType: MPU_ERR_TYPE_READ (Read access)
        - errReport.accessCtr: 0x8000 (Access violation occurs on region 0 - MSB is region 0 and so on)
        - errReport.addr: 0x1FFEFF00 (Data access in supervisor mode)
        - errReport.processorIdentification: 0U (Do not support for non-core processor)
     */
    ...
~~~~~
- The MPU_DRV_EnableRegion() can be used to enable or disable region descriptor.
~~~~~{.c}
    /* Disables DMA - disable region 1 descriptor */
    MPU_DRV_EnableRegion(INST_MPU, 1U, false);
    /* Enables again */
    MPU_DRV_EnableRegion(INST_MPU, 1U, true);
~~~~~

Power management:
- To minimizes power dissipation, disables MPU module or regions by using MPU_DRV_Deinit()/MPU_DRV_EnableRegion() when they are unused anymore.

 */
