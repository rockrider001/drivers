/*!
   @defgroup smpu System Memory Protection Unit (SMPU)
   @brief The S32 SDK provides Peripheral Drivers for the System Memory Protection Unit (SMPU) module of S32 SDK devices.
   @details

   ## Hardware background ##

    The System Memory Protection Unit (SMPU) provides hardware access control for
    system bus memory references. The SMPU concurrently monitors system bus
    transactions and evaluates their appropriateness using preprogrammed region descriptors
    that define memory spaces and their access rights. Memory references that have
    sufficient access control rights are allowed to complete, while references that are not
    mapped to any region descriptor or have insufficient rights are terminated with an access
    error response.

    The chip contains instance(s) of the System Memory Protection Unit (SMPU):
    - S32Rx7x, MPC574xR:
      - SMPU_0 for the data XBAR (XBAR_0)
      - SMPU_1 for the instruction XBAR (XBAR_1)
    - MPC5747C, MPC5748C, MPC5746G, MPC5747G and MPC5748G:
      - SMPU_0 protects flash and peripherals.
      - SMPU_1 protects RAM.
    - SJA1110:
      - SMPU_0 protects flash, peripherals and RAM (except Core master, only protect peripheral).
    - Others:
      - SMPU_0 protects flash, peripherals and RAM.

    The SMPU feature set includes:
    - Support for a maximum of 16 program-visible 192-bit region descriptors, accessible
    as six 32-bit words each.
    - Each region descriptor defines an arbitrarily-sized space, aligned anywhere in
    memory.
    - Region sizes can vary from a minimum of 1(16) byte(s) to a maximum of 4 GB (depend on Hardware revision level).
    - Read/write access control permissions are defined in the region descriptor.
    - Global cache-inhibit attribute indicator.
    - Hardware-assisted maintenance of the descriptor valid bit minimizes coherency
    issues.
    - Priority given to granting permission over denying access for overlapping region descriptors.
    - Detection of access errors if a memory reference does not hit in any memory region,
    or if the reference is illegal in all hit memory regions. If an access error occurs, the
    reference is terminated with an error response, and the SMPU inhibits the bus cycle
    being sent to the targeted slave device.
    - Instruction storage (ISI) or data storage (DSI) interrupts generated by aborted core
    accesses.
    - Error registers (per bus master ID) capture the last faulting address, attributes, and
    other information.
    - Global SMPU enable/disable control bit.

   ## Chip specific ##
    - MPC574x:
      - The cores on the device treats the following memory region as guarded by default:
        - Guarded Region0: Address 0xFC00_0000 to 0xFFFF_FFFF
        - Guarded Region1: Address 0xF800_0000 to 0xFBFF_FFFF
    - MPC574xR:
      - SMPU0 supports a maximum of 12 region descriptors.
      - SMPU1 supports a maximum of 8 region descriptors.
    - MPC574xB/C/G and S32Rx7x:
      - For each of the following masters, SMPU_EDRn[EATTR] always has the indicated fixed value:
        - ENET : 01
        - FlexRay : 11
        - SPT : 11

 */

/*!
@addtogroup smpu

## Integration guideline ##

### Compilation units ###

The following files need to be compiled in the project:
\verbatim
${S32SDK_PATH}\platform\drivers\src\smpu\smpu_driver.c
${S32SDK_PATH}\platform\drivers\src\smpu\smpu_hw_access.c
\endverbatim

### Include path ###

The following paths need to be added to the include path of the toolchain:
\verbatim
${S32SDK_PATH}\platform\drivers\inc\
\endverbatim

### Preprocessor symbols ###

No special symbols are required for this component

### Dependencies ###

No special dependencies are required for this component

 */

/*!
@addtogroup smpu

## Initialization and De-initialize

To initialize the SMPU module, call the SMPU_DRV_Init() function and provide the user configuration data structure.
This function sets the configuration of the SMPU module automatically. \n
Note before initializing:
 - The instance of SMPU should be used correctly follow the area want to be protected.

This is example code to configure the SMPU driver on MPC5748G:
1. Define SMPU instance
~~~~~{.c}
    /* SMPU 1 - RAM protection */
    #define INST_SMPU 1U

    /* Status variable */
    status_t status;
~~~~~

2. Configuration \n
User configuration
~~~~~{.c}
    /* Region count */
    #define REGION_CNT (1U)

    /* Master access configuration
     * FEATURE_SMPU_MASTER_COUNT macro has been already defined (number of masters supported by hardware)
     */
    smpu_master_access_right_t masterAccRight[FEATURE_SMPU_MASTER_COUNT] =
    {
       /* CORE Z4A (Depend on devices) */
        {
            .masterNum   = FEATURE_SMPU_MASTER_CORE_Z4A, /* Master number */
            .accessRight = SMPU_RW_OR_SET_3              /* Normal access right: allow read and write */
        },
        /* The rest masters should be defined here */
        ...
    }
    /* User configuration */
    smpu_user_config_t userConfig[REGION_CNT] =
    {
        /* Region 0 */
        {
            .startAddr          = 0x00000000U,        /* Start address */
            .endAddr            = 0xFFFFFFFFU,        /* End address */
            /* If Specific access supported */
            .specAccess         = false,              /* Use normal access rights */
            .specAccessSet      = NULL,               /* This parameter must be set if specific access is enabled */
            /* End if */
            .masterAccRight     = masterAccRight,     /* Master access right */
            .cacheInhibitEnable = false,              /* Cache inhibit */
            /* If PID supported */
            .processIdEnable    = false,              /* Process identifier enable */
            .processIdentifier  = 0x00U,              /* Process identifier */
            .processIdMask      = 0x00U,              /* Process identifier mask */
            /* End if */
            .lockConfig         = SMPU_UNLOCK         /* Lock configuration */
        }
    }
~~~~~
or get default configuration
~~~~~{.c}
    /* Defines master access right structure */
    smpu_master_access_right_t masterAccRight[FEATURE_SMPU_MASTER_COUNT];

    /* Gets default region configuration
     * Cover entire memory
     * Access rights of all masters are allowed
     */
    smpu_user_config_t regionConfig0 = SMPU_DRV_GetDefaultRegionConfig(masterAccRight);
    smpu_user_config_t userConfig[REGION_CNT] =
    {
        regionConfig0
    };
~~~~~

3. Initializes
~~~~~{.c}
    /* Initializes the SMPU instance */
    status = SMPU_DRV_Init(INST_SMPU, REGION_CNT, userConfig);
~~~~~

4. De-initializes
~~~~~{.c}
    /* De-initializes the SMPU instance */
    status = SMPU_DRV_Deinit(INST_SMPU);
~~~~~

## Basic Operations

After SMPU initialization:
- The SMPU_DRV_SetRegionConfig() can be used to configure the region descriptor.
- The SMPU_DRV_SetRegionAddr() can be used to configure the region start and end address.
- The SMPU_DRV_SetRegionProcessId() can be used to configure the region process identifier (if PID supported).
- The SMPU_DRV_EnableRegion() can be used to enable or disable a region descriptor.
- The SMPU_DRV_SetMasterAccessRights() can be used to configure access permission of master in the region.
- The SMPU_DRV_SetRegionLockConfig() can be used to set region lock configuration.
- The SMPU_DRV_GetRegionLockInfo() can be used to report the region lock status.
- The SMPU_DRV_GetDetailErrorInfo() can be used to check the status of master;
if the error occurs, the detail error information will be reported and the corresponding error flag will be cleared.

- Example:
  - Add/update the new/existing region descriptor.
~~~~~{.c}
    /* Add the new region descriptor.
       Region 1 to be the same with region 0.
     */
    status = SMPU_DRV_SetRegionConfig(INST_SMPU, 1U, &userConfig[0U]);

    /* Updates the existing region descriptor.
       Updates PID mask value on region 1.
     */
    userConfig[0U].processIdEnable = true;
    userConfig[0U].processIdMask = 0xFFU;
    status = SMPU_DRV_SetRegionConfig(INST_SMPU, 1U, &userConfig[0U]);
~~~~~
  - Update the start and end address on an existing region descriptor.
~~~~~{.c}
    /* Updates region 1 location (0x40000000 - 0x4FFFFFFF) */
    SMPU_DRV_SetRegionAddr(INST_SMPU, 1U, 0x40000000U, 0x40000FFFU);
~~~~~
  - Configure the region process identifier (if PID supported).
~~~~~{.c}
    /* Updates process identifier on region 0.
       pid_enable: true
       pid: 0x0F
       pid_mask: 0xF0
     */
    SMPU_DRV_SetRegionProcessId(INST_SMPU, 0U, true, 0x0FU, 0xF0U);
~~~~~
  - Update access permission of master in the region.
~~~~~{.c}
    /* DMA can only operate on region 1 */
    smpu_master_access_right_t DMA_AccRight;
    DMA_AccRight.masterNum = FEATURE_SMPU_MASTER_EDMA;
    /* Removes all access rights of DMA on region 0 */
    DMA_AccRight.accessRight = SMPU_NONE;
    status = MPU_DRV_SetMasterAccessRights(INST_SMPU, 0U, &DMA_AccRight);
    /* Allows all access to region 1 from DMA */
    DMA_AccRight.accessRight = SMPU_RW_OR_SET_3;
    status = MPU_DRV_SetMasterAccessRights(INST_SMPU, 1U, &DMA_AccRight);
~~~~~
  - Get the status of a slave port and the detail when an error occurred.
~~~~~{.c}
    /* eDMA access to SRAM
       - Access type: read
       - Address: 0x40001000U (region 0)
     */
    ...
    /* Checks and gets error status on eDMA master */
    bool errStatus = false;
    smpu_access_err_info_t errReport;
    errStatus =  SMPU_DRV_GetDetailErrorInfo(INST_SMPU, FEATURE_SMPU_MASTER_EDMA, &errReport);
    /* Checks status:
      - errStatus: true
      - errReport:
        - errReport.master: FEATURE_SMPU_MASTER_EDMA (eDMA logical ID)
        - errReport.overrun: false or true if read once or more.
        - errReport.attributes: SMPU_DATA_ACCESS_IN_SUPERVISOR_MODE (Data access in supervisor mode)
        - errReport.accessType: SMPU_ERR_TYPE_READ (Read access)
        - errReport.accessCtr: 0x800000 (Access violation occurs on region 0 - MSB (bit no.23 of 24-bit and decrease) is region 0 and so on)
        - errReport.addr: 0x40001000 (Address violation)
        - errReport.processorIdentification: 0U (Do not support for non-core processor)
     */
    ...
~~~~~
  - Set region lock configuration.
~~~~~{.c}
    /* Lock region 1 can only update by Core Z4A master */
    status = SMPU_DRV_SetRegionLockConfig(INST_SMPU, 1U, SMPU_OWNER_LOCK);
~~~~~
  - Report the region lock status.
~~~~~{.c}
    /* Gets the region 1 lock information */
    smpu_region_lock_t lockReport;
    lockReport = SMPU_DRV_GetRegionLockInfo(INST_SMPU, 1U);
    /* lockReport:
        - lockReport.regionNum: 0x1 (region 1)
        - lockReport.masterOwner: FEATURE_MPU_MASTER_CORE_Z4A (Core Z4A logical ID)
        - lockReport.lockConfig: SMPU_OWNER_LOCK (lock configuration)
     */
~~~~~
  - Enable or disable region descriptor.
~~~~~{.c}
    /* Disables DMA - disable region 1 descriptor */
    status = MPU_DRV_EnableRegion(INST_SMPU, 1U, false);
    /* Enables again */
    status = MPU_DRV_EnableRegion(INST_SMPU, 1U, true);
~~~~~


## Normal access rights

- Read (r) permission refers to the ability to access the referenced memory address
using an operand (data) fetch or an instruction fetch.
- Write (w) permission refers to the ability to update the referenced memory address
using a store (data) operation.

## Specific access rights

Specifies the separate access rights for supervisor mode and user mode:
- Read (r) permission refers to the ability to access the referenced memory address
using an operand (data) fetch.
- Write (w) permission refers to the ability to update the referenced memory address
using a store (data) operation.
- Execute (x) permission refers to the ability to read the referenced memory address
using an instruction fetch.

Each region supports configurable sets of access right and the masters will use one of them (e.g. 3 sets in each region).

## PID

A process identifier hit term is formed as: \n
<b>pid_hit = !region_pid_enable | ((current_pid | region_pid_mask) == (region_pid | region pid_mask))</b> \n
<i>region_pid_enable</i> : Allow PID or not. \n
<i>current_pid</i> : The current process identifier. \n
<i>region_pid</i> : The process identifier is on the region. \n
<i>region_pid_enable</i> : The process identifier mask is on the region.

## Note

1. All functions modifies the region descriptor will unlock the region if succeed.
2. If the region is locked by the master, only that master can modify the region descriptor.
3. Setting region lock configuration to SMPU_ALL_LOCK, the region descriptor cannot be modified by any master until system reset.

 */
